{"./":{"url":"./","title":"前言","keywords":"","body":"数据结构算法源码 线性表 顺序表的基本运算 单链表的基本运算 循环单链表的基本运算 双链表的基本运算 循环双链表的基本运算 顺序表求约瑟夫问题 两个多项式相加运算 栈 顺序栈基本运算 链栈基本运算 队列 顺序队基本运算 链队基本运算 看病排队问题 串和数组 顺序串基本运算 链串基本运算 二叉树 二叉树基本运算 二叉树4种遍历算法 哈夫曼树 图 有向图连接矩阵 有向图连接链表 广度优先遍历 深度优先遍历 普里姆算法 克鲁斯卡尔算法 狄克斯特拉算法 弗洛伊德算法 查找 顺序查找 二分法查找 分块查找 二叉排序树查找 哈希表查找 哈希查找 排序 插入排序 希尔排序 选择排序 堆排序 冒泡排序 快速排序 归并排序 基数排序 拓扑排序算法 Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 17:46:53 "},"list/sqlist.html":{"url":"list/sqlist.html","title":"顺序表的基本运算","keywords":"","body":"顺序表的基本运算 #include #define MAXSIZE 100 /*顺序表的容量*/ typedef char ElemType; typedef struct { ElemType data[MAXSIZE]; /*存放顺序表的元素*/ int length; /*顺序表的实际长度*/ } SqList; void InitList(SqList &sq) /*初始化线性表*/ { sq.length = 0; } int GetLength(SqList sq) /*求线性表长度*/ { return sq.length; } int GetElem(SqList sq, int i, ElemType &e) /*求线性表中第i个元素*/ { if (i sq.length) /*无效的i值*/ return 0; else { e = sq.data[i - 1]; return 1; } } int Locate(SqList sq, ElemType x) /*按值查找*/ { int i = 0; while (sq.data[i] != x) /*查找值为x的第1个结点*/ i++; if (i > sq.length) return (0); /*未找到*/ else return (i + 1); } int InsElem(SqList &sq, ElemType x, int i) /*插入元素*/ { int j; if (i sq.length + 1) /*无效的参数i*/ return 0; for (j = sq.length; j > i; j--) /*将位置为i的结点及之后的结点后移*/ sq.data[j] = sq.data[j - 1]; sq.data[i - 1] = x; /*在位置i处放入x*/ sq.length++; /*线性表长度增1*/ return 1; } int DelElem(SqList &sq, int i) /*删除元素*/ { int j; if (i sq.length) /*无效的参数i*/ return 0; for (j = i; j Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"list/single-link.html":{"url":"list/single-link.html","title":"单链表的基本运算","keywords":"","body":"单链表的基本运算 By C++ #include #include typedef char ElemType; typedef struct node { ElemType data; /*数据域*/ struct node *next; /*指针域*/ } SLink; void InitList(SLink *&L) /*L作为引用型参数*/ { L=(SLink *)malloc(sizeof(SLink)); /*创建头结点*L*/ L->next=NULL; } int GetLength(SLink *L) /*求线性表的长度*/ { int i=0; SLink *p=L->next; while (p!=NULL) { i++; p=p->next; } return i; } int GetElem(SLink *L,int i,ElemType &e) /*求线性表中第i个元素*/ { int j=1; SLink *p=L->next; if (iGetLength(L)) return(0); /*i参数不正确,返回0*/ while (jnext;j++; } e=p->data; return(1); /*返回1*/ } int Locate(SLink *L,ElemType x) /*按值查找*/ { int i=1; SLink *p=L->next; while (p!=NULL && p->data!=x) /*从第1个结点开始查找data域为x的结点*/ { p=p->next; i++; } if (p==NULL) return(0); else return(i); } int InsElem(SLink *L,ElemType x,int i) /*插入结点*/ { int j=1; SLink *p=L,*s; s=(SLink *)malloc(sizeof(SLink)); /*创建data域为x的结点*/ s->data=x;s->next=NULL; if (iGetLength(L)+1) return 0; /*i参数不正确,插入失败,返回0*/ while (jnext;j++; } s->next=p->next; /*将*s的next域指向*p的下一个结点(即第i个结点)*/ p->next=s; /*将*p的next域指向*s,这样*s变成第i个结点*/ return 1; /*插入运算成功,返回1*/ } int DelElem(SLink *L,int i) /*删除结点*/ { int j=1; SLink *p=L,*q; if (iGetLength(L)) return 0; /*i参数不正确,插入失败,返回0*/ while (jnext;j++; } q=p->next; /*由q指向第i个结点*/ p->next=q->next; /*将*p的next指向*q之后结点,即从链表中删除第i个结点*/ free(q); /*释放第i个结点占用的空间*/ return 1; /*删除运算成功,返回1*/ } void DispList(SLink *L) /*输出单链表*/ { SLink *p=L->next; while (p!=NULL) { printf(\"%c \",p->data); p=p->next; } printf(\"\\n\"); } void main() { int i; ElemType e; SLink *L; InitList(L); /*初始化单链表L*/ InsElem(L,'a',1); /*插入元素*/ InsElem(L,'c',2); InsElem(L,'a',3); InsElem(L,'e',4); InsElem(L,'d',5); InsElem(L,'b',6); printf(\"线性表:\");DispList(L); printf(\"长度:%d\\n\",GetLength(L)); i=3;GetElem(L,i,e); printf(\"第%d个元素:%c\\n\",i,e); e='a'; printf(\"元素%c是第%d个元素\\n\",e,Locate(L,e)); i=4;printf(\"删除第%d个元素\\n\",i); DelElem(L,i); printf(\"线性表:\");DispList(L); } By Golang // Package linkedlist creates a ItemLinkedList data structure for the Item type package linkedlist import ( \"fmt\" \"sync\" ) // Item the type of the linked list type Item interface{} // Node a single node that composes the list type Node struct { content Item next *Node } // ItemLinkedList the linked list of Items type ItemLinkedList struct { head *Node size int lock sync.RWMutex } // Append adds an Item to the end of the linked list func (ll *ItemLinkedList) Append(t Item) { ll.lock.Lock() node := Node{t, nil} if ll.head == nil { ll.head = &node } else { last := ll.head for { if last.next == nil { break } last = last.next } last.next = &node } ll.size++ ll.lock.Unlock() } // Insert adds an Item at position i func (ll *ItemLinkedList) Insert(i int, t Item) error { ll.lock.Lock() defer ll.lock.Unlock() if i ll.size { return fmt.Errorf(\"Index out of bounds\") } addNode := Node{t, nil} if i == 0 { addNode.next = ll.head ll.head = &addNode return nil } node := ll.head j := 0 for j ll.size { return nil, fmt.Errorf(\"Index out of bounds\") } node := ll.head j := 0 for j Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 17:37:38 "},"list/circular-single-link.html":{"url":"list/circular-single-link.html","title":"循环单链表的基本运算","keywords":"","body":"循环单链表的基本运算 #include #include typedef char ElemType; typedef struct node { ElemType data; /*数据域*/ struct node *next; /*指针域*/ } SLink; void InitList(SLink *&L) /*初始化线性表,L为引用型参数*/ { L=(SLink *)malloc(sizeof(SLink)); L->next=L; } int GetLength(SLink *L) /*求线性表的长度*/ { int i=0; SLink *p=L->next; while (p!=L) { i++;p=p->next; } return i; } int GetElem(SLink *L,int i,ElemType &e) /*求线性表中第i个元素*/ { int j=1; SLink *p=L->next; if (iGetLength(L)) return(0); /*i参数不正确,返回0*/ while (jnext; j++; } e=p->data; return(1); /*返回1*/ } int Locate(SLink *L,ElemType x) /*按值查找*/ { int i=1; SLink *p=L->next; while (p!=L && p->data!=x) /*从第1个结点开始查找data域为x的结点*/ { p=p->next; i++; } if (p==L) return(0); else return(i); } int InsElem(SLink *L,ElemType x,int i) /*插入结点*/ { int j=1; SLink *p=L,*s; s=(SLink *)malloc(sizeof(SLink)); s->data=x;s->next=NULL; if (iGetLength(L)+1) return 0; while (jnext;j++; } s->next=p->next; p->next=s; return 1; } int DelElem(SLink *L,int i) /*删除结点*/ { int j=1; SLink *p=L,*q; if (iGetLength(L)) return 0; while (jnext;j++; } q=p->next; p->next=q->next; free(q); return 1; } void DispList(SLink *L) /*输出线性表*/ { SLink *p=L->next; while (p!=L) { printf(\"%c \",p->data);p=p->next; } printf(\"\\n\"); } void main() { int i; ElemType e; SLink *L; InitList(L); /*初始化单链表L*/ InsElem(L,'a',1); /*插入元素*/ InsElem(L,'c',2); InsElem(L,'a',3); InsElem(L,'e',4); InsElem(L,'d',5); InsElem(L,'b',6); printf(\"线性表:\");DispList(L); printf(\"长度:%d\\n\",GetLength(L)); i=3;GetElem(L,i,e); printf(\"第%d个元素:%c\\n\",i,e); e='a'; printf(\"元素%c是第%d个元素\\n\",e,Locate(L,e)); i=4;printf(\"删除第%d个元素\\n\",i); DelElem(L,i); printf(\"线性表:\");DispList(L); } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"list/double-link.html":{"url":"list/double-link.html","title":"双链表的基本运算","keywords":"","body":"双链表的基本运算 #include #include typedef char ElemType; typedef struct node { ElemType data; /*数据域*/ struct node *prior,*next; /*分别指向前驱结点和后继结点的指针*/ } DLink; void InitList(DLink *&L) { L=(DLink *)malloc(sizeof(DLink)); /*创建头结点*L*/ L->prior=L->next=NULL; } int GetLength(DLink *L) /*求表长运算*/ { int i=0; DLink *p=L->next; while (p!=NULL) { i++;p=p->next; } return i; } int GetElem(DLink *L,int i,ElemType &e) /*求线性表中第i个元素*/ { int j=1; DLink *p=L->next; if (iGetLength(L)) return(0); /*i参数不正确,返回0*/ while (jnext;j++; } e=p->data; return(1); /*返回1*/ } int Locate(DLink *L,ElemType x) /*按值查找*/ { int i=1; DLink *p=L->next; while (p!=NULL && p->data!=x) /*从第1个结点开始查找data域为x的结点*/ { p=p->next; i++; } if (p==NULL) return(0); else return(i); } int InsElem(DLink *L,ElemType x,int i) /*插入运算*/ { int j=1; DLink *p=L,*s; s=(DLink *)malloc(sizeof(DLink)); /*创建data域为x的结点*/ s->data=x;s->prior=s->next=NULL; if (iGetLength(L)+1) /*i参数不正确,插入失败,返回0*/ return 0; while (jnext;j++; } s->next=p->next; /**s的next域指向*p的下一个结点*/ s->prior=p; /**s的prior域指向*p*/ if (p->next!=NULL) /*若*p不是最后结点,则将*p之后结点的prior域指向*s*/ s->next->prior=s; p->next=s; /**p的next域指向*s*/ return 1; /*插入运算成功,返回1*/ } int DelElem(DLink *L,int i) /*删除运算*/ { int j=1; DLink *p=L,*q; if (iGetLength(L)) /*i参数不正确,删除失败,返回0*/ return 0; while (jnext;j++; } q=p->next; /*q指向*p的下一个结点,即要删除的结点*/ p->next=q->next; if (q->next!=NULL) /*若*q不是最后结点,则将*q之后结点的prior域指向*p*/ q->next->prior=p; free(q); /*释放第i个结点占用的空间*/ return 1; /*删除运算成功,返回1*/ } void DispList(DLink *L) /*输出线性表*/ { DLink *p=L->next; while (p!=NULL) { printf(\"%c \",p->data);p=p->next; } printf(\"\\n\"); } void main() { int i; ElemType e; DLink *L; InitList(L); /*初始化双链表L*/ InsElem(L,'a',1); /*插入元素*/ InsElem(L,'c',2); InsElem(L,'a',3); InsElem(L,'e',4); InsElem(L,'d',5); InsElem(L,'b',6); printf(\"线性表:\");DispList(L); printf(\"长度:%d\\n\",GetLength(L)); i=3;GetElem(L,i,e); printf(\"第%d个元素:%c\\n\",i,e); e='a'; printf(\"元素%c是第%d个元素\\n\",e,Locate(L,e)); i=4;printf(\"删除第%d个元素\\n\",i); DelElem(L,i); printf(\"线性表:\");DispList(L); } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"list/circular-double-link.html":{"url":"list/circular-double-link.html","title":"循环双链表的基本运算","keywords":"","body":"循环双链表的基本运算 #include #include typedef char ElemType; typedef struct node { ElemType data; /*数据域*/ struct node *prior,*next; /*分别指向前驱结点和后继结点的指针*/ } DLink; void InitList(DLink *&L) { L=(DLink *)malloc(sizeof(DLink)); L->prior=L->next=L; } int GetLength(DLink *L) /*求表长运算*/ { int i=0; DLink *p=L->next; while (p!=L) { i++;p=p->next; } return i; } int GetElem(DLink *L,int i,ElemType &e) /*求线性表中第i个元素*/ { int j=1; DLink *p=L->next; if (iGetLength(L)) return(0); /*i参数不正确,返回0*/ while (jnext;j++; } e=p->data; return(1); /*返回1*/ } int Locate(DLink *L,ElemType x) /*按值查找*/ { int i=1; DLink *p=L->next; while (p!=L && p->data!=x) /*从第1个结点开始查找data域为x的结点*/ { p=p->next; i++; } if (p==L) return(0); else return(i); } int InsElem(DLink *L,ElemType x,int i) /*插入运算*/ { int j=1; DLink *p=L,*s; s=(DLink *)malloc(sizeof(DLink)); s->data=x;s->prior=s->next=NULL; if (iGetLength(L)+1) return 0; while (jnext;j++; } s->next=p->next; /*s的next域指向p之后的结点*/ s->next->prior=s; /*p之后结点的prior域指向s*/ p->next=s; /*p的next域指向s*/ s->prior=p; /*s的prior域指向p*/ return 1; } int DelElem(DLink *L,int i) /*删除运算*/ { int j=1; DLink *p=L,*q; if (iGetLength(L)) return 0; while (jnext;j++; } q=p->next; /*q指向p的下一个结点,即要删除的结点*/ p->next=q->next; /*p的next指向q的下一个结点*/ q->next->prior=p; /*q的下一个结点的prior域指向p*/ free(q); /*释放q所占用的空间*/ return 1; } void DispList(DLink *L) /*输出线性表*/ { DLink *p=L->next; while (p!=L) { printf(\"%c \",p->data);p=p->next; } printf(\"\\n\"); } void main() { int i; ElemType e; DLink *L; InitList(L); /*初始化双链表L*/ InsElem(L,'a',1); /*插入元素*/ InsElem(L,'c',2); InsElem(L,'a',3); InsElem(L,'e',4); InsElem(L,'d',5); InsElem(L,'b',6); printf(\"线性表:\");DispList(L); printf(\"长度:%d\\n\",GetLength(L)); i=3;GetElem(L,i,e); printf(\"第%d个元素:%c\\n\",i,e); e='a'; printf(\"元素%c是第%d个元素\\n\",e,Locate(L,e)); i=4;printf(\"删除第%d个元素\\n\",i); DelElem(L,i); printf(\"线性表:\");DispList(L); } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"list/jose.html":{"url":"list/jose.html","title":"顺序表求约瑟夫问题","keywords":"","body":"顺序表求解约瑟夫问题 #include #define MaxSize 50 void jose(int n,int m) { int mon[MaxSize]; /*存放n个猴子的编号*/ int i,d,count; for (i=0;i Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"list/poly.html":{"url":"list/poly.html","title":"两个多项式相加运算","keywords":"","body":"两个多项式相加运算 #include #include typedef struct node { float coef; /*序数*/ int expn; /*指数*/ struct node *next; /*指向下一个结点的指针*/ } PolyNode; void InitList(PolyNode *&L) /*初始化多项式单链表*/ { L=(PolyNode *)malloc(sizeof(PolyNode)); /*建立头结点*/ L->next=NULL; } int GetLength(PolyNode *L) /*求多项式单链表的长度*/ { int i=0; PolyNode *p=L->next; while (p!=NULL) /*扫描单链表L,用i累计数据结点个数*/ { i++;p=p->next; } return i; } PolyNode *GetElem(PolyNode *L,int i) /*返回多项式单链表中第i个结点的指针*/ { int j=1; PolyNode *p=L->next; if (iGetLength(L)) return NULL; while (jnext;j++; } return p; } PolyNode *Locate(PolyNode *L,float c,int e) /*在多项式单链表中按值查找*/ { PolyNode *p=L->next; while (p!=NULL && (p->coef!=c ||p->expn!=e)) p=p->next; return p; } int InsElem(PolyNode *&L,float c,int e,int i) /*在多项式单链表中插入一个结点*/ { int j=1; PolyNode *p=L,*s; s=(PolyNode *)malloc(sizeof(PolyNode)); s->coef=c;s->expn=e;s->next=NULL; if (iGetLength(L)+1) return 0; while (jnext;j++; } s->next=p->next; p->next=s; return 1; } int DelElem(PolyNode *L,int i) /*在多项式单链表中删除一个结点*/ { int j=1; PolyNode *p=L,*q; if (iGetLength(L)) return 0; while (jnext;j++; } q=p->next; p->next=q->next; free(q); return 1; } void DispList(PolyNode *L) /*输出多项式单链表的元素值*/ { PolyNode *p=L->next; while (p!=NULL) { printf(\"(%g,%d) \",p->coef,p->expn); p=p->next; } printf(\"\\n\"); } void CreaPolyList(PolyNode *&L,float C[],int E[],int n) { int i; InitList(L); for (i=0;inext,*q,*pre; L->next=NULL; while (p!=NULL) { if (L->next==NULL) /*处理第1个结点*/ { L->next=p;p=p->next; L->next->next=NULL; } else /*处理其余结点*/ { pre=L;q=pre->next; while (q!=NULL && p->expn>q->expn) /*找q->expn刚大于或等于p->expn的结点*q的前驱结点*pre*/ { pre=q;q=q->next; } q=p->next; /*在*pre结点之后插入*p*/ p->next=pre->next; pre->next=p; p=q; } } } PolyNode *AddPoly(PolyNode *pa,PolyNode *pb) { PolyNode *pc,*p1=pa->next,*p2=pb->next,*p,*tc,*s; pc=(PolyNode *)malloc(sizeof(PolyNode)); /*新建头结点*/ pc->next=NULL; /*pc为新建单链表的头结点*/ tc=pc; /*tc始终指向新建单链表的最后结点*/ while (p1!=NULL && p2!=NULL) { if (p1->expnexpn) /*将*p1结点复制到*s并链到pc尾*/ { s=(PolyNode *)malloc(sizeof(PolyNode)); s->coef=p1->coef;s->expn=p1->expn;s->next=NULL; tc->next=s;tc=s; p1=p1->next; } else if (p1->expn>p2->expn) /*将*p2结点复制到*s并链到pc尾*/ { s=(PolyNode *)malloc(sizeof(PolyNode)); s->coef=p2->coef;s->expn=p2->expn;s->next=NULL; tc->next=s;tc=s; p2=p2->next; } else /*p1->expn=p2->expn的情况*/ { if (p1->coef+p2->coef!=0) /*序数相加不为0时新建结点*s并链到pc尾*/ { s=(PolyNode *)malloc(sizeof(PolyNode)); s->coef=p1->coef+p2->coef;s->expn=p1->expn; s->next=NULL; tc->next=s;tc=s; } p1=p1->next;p2=p2->next; } } if (p1!=NULL) p=p1; /*将尚未扫描完的余下结点复制并链接到pc单链表之后*/ else p=p2; while (p!=NULL) { s=(PolyNode *)malloc(sizeof(PolyNode)); s->coef=p->coef;s->expn=p->expn;s->next=NULL; tc->next=s;tc=s; p=p->next; } tc->next=NULL; /*新建单链表最后结点的next域置空*/ return pc; } void main() { PolyNode *L1,*L2,*L3; float C1[]={3,7,5,9},C2[]={-9,8,22}; int E1[]={1,0,17,8},E2[]={8,1,7}; InitList(L1); InitList(L2); InitList(L3); CreaPolyList(L1,C1,E1,4); CreaPolyList(L2,C2,E2,3); printf(\"两多项式相加运算\\n\"); printf(\" 原多项式A:\");DispList(L1); printf(\" 原多项式B:\");DispList(L2); SortPloy(L1); SortPloy(L2); printf(\"排序后的多项式A:\");DispList(L1); printf(\"排序后的多项式B:\");DispList(L2); L3=AddPoly(L1,L2); printf(\"多项式相加结果:\");DispList(L3); } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"stack/sqstack.html":{"url":"stack/sqstack.html","title":"顺序栈基本运算","keywords":"","body":"顺序栈的基本运算 By C++ #include typedef char ElemType; #define StackSize 100 /*顺序栈的初始分配空间*/ typedef struct { ElemType data[StackSize]; /*保存栈中元素*/ int top; /*栈指针*/ } SqStack; void InitStack(SqStack &st) /*st为引用型参数*/ { st.top=-1; } int Push(SqStack &st,ElemType x) /*进栈运算,st为引用型参数*/ { if (st.top==StackSize-1) /*栈满*/ return 0; else /*栈不满*/ { st.top++; st.data[st.top]=x; return 1; } } int Pop(SqStack &st,ElemType &x) /*出栈运算,st和x为引用型参数*/ { if (st.top==-1) /*栈空*/ return 0; else /*栈不空*/ { x=st.data[st.top]; st.top--; return 1; } } int GetTop(SqStack st,ElemType &x) /*取栈顶元素,x为引用型参数*/ { if (st.top==-1) /*栈空*/ return 0; else { x=st.data[st.top]; return 1; } } int StackEmpty(SqStack st) /*判断栈空运算*/ { if (st.top==-1) /*栈空*/ return 1; else /*栈不空*/ return 0; } void main() { SqStack st; ElemType e; InitStack(st); printf(\"栈%s\\n\",(StackEmpty(st)==1?\"空\":\"不空\")); printf(\"a进栈\\n\");Push(st,'a'); printf(\"b进栈\\n\");Push(st,'b'); printf(\"c进栈\\n\");Push(st,'c'); printf(\"d进栈\\n\");Push(st,'d'); printf(\"栈%s\\n\",(StackEmpty(st)==1?\"空\":\"不空\")); GetTop(st,e); printf(\"栈顶元素:%c\\n\",e); printf(\"出栈次序:\"); while (!StackEmpty(st)) { Pop(st,e); printf(\"%c \",e); } printf(\"\\n\"); } By Golang // Package stack creates a ItemStack data structure for the Item type package stack import ( \"sync\" ) // Item the type of the stack type Item interface{} // ItemStack the stack of Items type ItemStack struct { items []Item lock sync.RWMutex } // New creates a new ItemStack func (s *ItemStack) New() *ItemStack { s.items = []Item{} return s } // Push adds an Item to the top of the stack func (s *ItemStack) Push(t Item) { s.lock.Lock() s.items = append(s.items, t) s.lock.Unlock() } // Pop removes an Item from the top of the stack func (s *ItemStack) Pop() *Item { s.lock.Lock() item := s.items[len(s.items)-1] s.items = s.items[0 : len(s.items)-1] s.lock.Unlock() return &item } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 17:34:28 "},"stack/linkstack.html":{"url":"stack/linkstack.html","title":"链栈基本运算","keywords":"","body":"链栈的基本运算 #include typedef char ElemType; typedef struct lsnode { ElemType data; /*存储结点数据*/ struct lsnode *next; /*指针域*/ } LinkStack; void InitStack(LinkStack *&ls) /*ls为引用型参数*/ { ls=NULL; } void Push(LinkStack *&ls,ElemType x) /*进栈运算,ls为引用型参数*/ { LinkStack *p; p=(LinkStack *)malloc(sizeof(LinkStack)); p->data=x; p->next=ls; ls=p; } int Pop(LinkStack *&ls,ElemType &x) /*出栈运算,ls为引用型参数*/ { LinkStack *p; if (ls==NULL) /*栈空,下溢出*/ return 0; else { p=ls; x=p->data; ls=p->next; free(p); return 1; } } int GetTop(LinkStack *ls,ElemType &x) /*取栈顶元素运算*/ { if (ls==NULL) /*栈空,下溢出*/ return 0; else { x=ls->data; return 1; } } int StackEmpty(LinkStack *ls) /*判断栈空运算*/ { if (ls==NULL) return 1; else return 0; } void main() { LinkStack *ls; ElemType e; InitStack(ls); printf(\"栈%s\\n\",(StackEmpty(ls)==1?\"空\":\"不空\")); printf(\"a进栈\\n\");Push(ls,'a'); printf(\"b进栈\\n\");Push(ls,'b'); printf(\"c进栈\\n\");Push(ls,'c'); printf(\"d进栈\\n\");Push(ls,'d'); printf(\"栈%s\\n\",(StackEmpty(ls)==1?\"空\":\"不空\")); GetTop(ls,e); printf(\"栈顶元素:%c\\n\",e); printf(\"出栈次序:\"); while (!StackEmpty(ls)) { Pop(ls,e); printf(\"%c \",e); } printf(\"\\n\"); } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 17:33:23 "},"queue/sqqueue.html":{"url":"queue/sqqueue.html","title":"顺序队基本运算","keywords":"","body":"顺序队的基本运算 By C++ #include #define QueueSize 100 typedef char ElemType; typedef struct { ElemType data[QueueSize]; /*保存队中元素*/ int front,rear; /*队头和队尾指针*/ } SqQueue; void InitQueue(SqQueue &qu) /*qu为引用型参数*/ { qu.rear=qu.front=0; /*指针初始化*/ } int EnQueue(SqQueue &qu,ElemType x) /*入队运算,qu为引用型参数*/ { if ((qu.rear+1)%QueueSize==qu.front) /*队满*/ return 0; qu.rear=(qu.rear+1)%QueueSize; /*队尾指针进1*/ qu.data[qu.rear]=x; return 1; } int DeQueue(SqQueue &qu,ElemType &x) /*出队运算,qu和x为引用型参数*/ { if (qu.rear==qu.front) return 0; qu.front=(qu.front+1)%QueueSize; /*队头指针进1*/ x=qu.data[qu.front]; return 1; } int GetHead(SqQueue qu,ElemType &x) /*取队头元素运算,x为引用型参数*/ { if (qu.rear==qu.front) /*队空*/ return 0; x=qu.data[(qu.front+1)%QueueSize]; return 1; } int QueueEmpty(SqQueue qu) /*判断队空运算*/ { if (qu.rear==qu.front) /*队空*/ return 1; else return 0; } void main() { SqQueue qu; ElemType e; InitQueue(qu); printf(\"队%s\\n\",(QueueEmpty(qu)==1?\"空\":\"不空\")); printf(\"a进队\\n\");EnQueue(qu,'a'); printf(\"b进队\\n\");EnQueue(qu,'b'); printf(\"c进队\\n\");EnQueue(qu,'c'); printf(\"d进队\\n\");EnQueue(qu,'d'); printf(\"队%s\\n\",(QueueEmpty(qu)==1?\"空\":\"不空\")); GetHead(qu,e); printf(\"队头元素:%c\\n\",e); printf(\"出队次序:\"); while (!QueueEmpty(qu)) { DeQueue(qu,e); printf(\"%c \",e); } printf(\"\\n\"); } By Golang // Package queue creates a ItemQueue data structure for the Item type package queue import ( \"sync\" ) // Item the type of the queue type Item interface{} // ItemQueue the queue of Items type ItemQueue struct { items []Item lock sync.RWMutex } // New creates a new ItemQueue func (s *ItemQueue) New() *ItemQueue { s.lock.Lock() s.items = []Item{} s.lock.Unlock() return s } // Enqueue adds an Item to the end of the queue func (s *ItemQueue) Enqueue(t Item) { s.lock.Lock() s.items = append(s.items, t) s.lock.Unlock() } // Dequeue removes an Item from the start of the queue func (s *ItemQueue) Dequeue() *Item { s.lock.Lock() item := s.items[0] s.items = s.items[1:len(s.items)] s.lock.Unlock() return &item } // Front returns the item next in the queue, without removing it func (s *ItemQueue) Front() *Item { s.lock.RLock() item := s.items[0] s.lock.RUnlock() return &item } // IsEmpty returns true if the queue is empty func (s *ItemQueue) IsEmpty() bool { s.lock.RLock() defer s.lock.RUnlock() return len(s.items) == 0 } // Size returns the number of Items in the queue func (s *ItemQueue) Size() int { s.lock.RLock() defer s.lock.RUnlock() return len(s.items) } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 17:35:31 "},"queue/linkqueue.html":{"url":"queue/linkqueue.html","title":"链队基本运算","keywords":"","body":"链队的基本运算 #include #include typedef char ElemType; typedef struct QNode { ElemType data; struct QNode *next; } QType; /*链队中结点的类型*/ typedef struct qptr { QType *front,*rear; } LinkQueue; /*链队类型*/ void InitQueue(LinkQueue *&lq) /*lq为引用型参数*/ { lq=(LinkQueue *)malloc(sizeof(LinkQueue)); lq->rear=lq->front=NULL; /*初始情况*/ } void EnQueue(LinkQueue *&lq,ElemType x) /*入队运算,lq为引用型参数*/ { QType *s; s=(QType *)malloc(sizeof(QType)); /*创建新结点，插入到链队的末尾*/ s->data=x;s->next=NULL; if (lq->front==NULL && lq->rear==NULL) /*空队*/ lq->rear=lq->front=s; else { lq->rear->next=s; lq->rear=s; } } int DeQueue(LinkQueue *&lq,ElemType &x) /*出队运算,lq和x均为引用型参数*/ { QType *p; if (lq->front==NULL && lq->rear==NULL) /*空队*/ return 0; p=lq->front; x=p->data; if (lq->rear==lq->front) /*若原队列中只有一个结点,删除后队列变空*/ lq->rear=lq->front=NULL; else lq->front=lq->front->next; free(p); return 1; } int GetHead(LinkQueue *lq,ElemType &x) /*取队头元素运算,x为引用型参数*/ { if (lq->front==NULL && lq->rear==NULL) /*队空*/ return 0; x=lq->front->data; return 1; } int QueueEmpty(LinkQueue *lq) /*判断队空运算*/ { if (lq->front==NULL && lq->rear==NULL) return 1; else return 0; } void main() { LinkQueue *lq; ElemType e; InitQueue(lq); printf(\"队%s\\n\",(QueueEmpty(lq)==1?\"空\":\"不空\")); printf(\"a进队\\n\");EnQueue(lq,'a'); printf(\"b进队\\n\");EnQueue(lq,'b'); printf(\"c进队\\n\");EnQueue(lq,'c'); printf(\"d进队\\n\");EnQueue(lq,'d'); printf(\"队%s\\n\",(QueueEmpty(lq)==1?\"空\":\"不空\")); GetHead(lq,e); printf(\"队头元素:%c\\n\",e); printf(\"出队次序:\"); while (!QueueEmpty(lq)) { DeQueue(lq,e); printf(\"%c \",e); } printf(\"\\n\"); } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"queue/seedoctor.html":{"url":"queue/seedoctor.html","title":"看病排队问题","keywords":"","body":"看病排队问题 #include #include #include typedef struct QNode { char data[10]; struct QNode *next; } QType; /*链队结点类型*/ typedef struct { QType *front,*rear; } LinkQueue; /*链队类型*/ void SeeDoctor() { int sel,flag=1; LinkQueue *lq; QType *s; char name[10]; lq=(LinkQueue *)malloc(sizeof(LinkQueue)); lq->front=(QType *)malloc(sizeof(QType)); lq->front->next=NULL; lq->rear=lq->front; while (flag==1) /*未下班时循环执行*/ { printf(\"1:排队 2:看医生 3:查看排队 0:下班 请选择:\"); scanf(\"%d\",&sel); switch(sel) { case 0: if (lq->front!=lq->rear) /*队不空*/ printf(\" >>请排队的患者明天就医\\n\"); flag=0; break; case 1: printf(\" >>输入患者姓名:\");scanf(\"%s\",name); s=(QType *)malloc(sizeof(QType)); strcpy(s->data,name);s->next=NULL; lq->rear->next=s;lq->rear=s; break; case 2: if (lq->front==lq->rear) /*队空*/ printf(\" >>没有排队的患者\\n\"); else { s=lq->front->next; if (lq->rear==s) lq->rear=lq->front; printf(\" >>患者%s看医生\\n\",s->data); lq->front->next=s->next; free(s); } break; case 3: if (lq->front==lq->rear) /*队空*/ printf(\" >>没有排列的患者\\n\"); else { s=lq->front->next; printf(\" >>排队患者:\"); while (s!=NULL) { printf(\"%s \",s->data); s=s->next; } printf(\"\\n\"); } break; } } } void main() { SeeDoctor(); } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"string/sqstring.html":{"url":"string/sqstring.html","title":"顺序串基本运算","keywords":"","body":"顺序串的基本运算 #include #define MaxSize 100 /*最多字符个数*/ typedef struct { char ch[MaxSize]; /*存放串字符*/ int len; /*存放串的实际长度*/ } SqString; /*顺序串类型*/ void Assign(SqString &s,char t[]) /*串赋值运算*/ { int i=0; while (t[i]!='\\0') { s.ch[i]=t[i]; i++; } s.len=i; } void StrCopy(SqString &s,SqString t) /*串复制运算*/ { int i; for (i=0;is.len || js.len+1) t.len=0; /*参数错误时返回空串*/ else { for (k=i-1;k=t.len) k=i-t.len+1;/*求出第一个字符的位置*/ else k=-1; /*置特殊值-1*/ return(k); } int InsStr(SqString &s,int i,SqString t) /*子串插入运算*/ { int j; if (i>s.len+1) return(0); /*位置参数值错误*/ else { for (j=s.len;j>=i-1;j--) /*将s.ch[i-1]-s.ch[s.len-1]*/ s.ch[j+t.len]=s.ch[j]; /*后移t.len个位置*/ for (j=0;js.len || js.len+1) return(0); /*位置参数值错误*/ else { for (k=i+j-1;k=0) { DelStr(s,i,s1.len); /*删除*/ InsStr(s,i,s2); /*插入*/ i=Index(s,s1); } return(s); } void DispStr(SqString s) /*输出串运算*/ { int i; for (i=0;is2\\n\"); StrCopy(s2,s1); printf(\"s2:\");DispStr(s2); printf(\"s1和s2%s\\n\",(StrEqual(s1,s2)==1?\"相同\":\"不相同\")); Assign(s3,\"12345678\"); printf(\"s3:\");DispStr(s3); printf(\"s1和s3连接=>s4\\n\"); s4=Concat(s1,s3); printf(\"s4:\");DispStr(s4); printf(\"s3[2..5]=>s5\\n\"); s5=SubStr(s3,2,4); printf(\"s5:\");DispStr(s5); Assign(s6,\"567\"); printf(\"s6:\");DispStr(s6); printf(\"s6在s3中位置:%d\\n\",Index(s3,s6)); printf(\"从s3中删除s3[3..6]字符\\n\"); DelStr(s3,3,4); printf(\"s3:\");DispStr(s3); printf(\"从s4中将s6替换成s1=>s7\\n\"); s7=RepStrAll(s4,s6,s1); printf(\"s7:\");DispStr(s7); } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"string/linkstring.html":{"url":"string/linkstring.html","title":"链串基本运算","keywords":"","body":"链串的基本运算 #include #include typedef struct node { char data; /*存放字符*/ struct node *next; /*指针域*/ } LinkString; void Assign(LinkString *&s,char t[]) { int i=0; LinkString *q,*tc; s=(LinkString *)malloc(sizeof(LinkString)); /*建立头结点*/ s->next=NULL; tc=s; /*tc指向s串的尾结点*/ while (t[i]!='\\0') { q=(LinkString *)malloc(sizeof(LinkString)); q->data=t[i]; tc->next=q;tc=q; i++; } tc->next=NULL; /*终端结点的next置NULL*/ } void StrCopy(LinkString *&s,LinkString *t) /*t=>s*/ { LinkString *p=t->next,*q,*tc; s=(LinkString *)malloc(sizeof(LinkString)); /*建立头结点*/ s->next=NULL; tc=s; /*tc指向s串的尾结点*/ while (p!=NULL) /*复制t的所有结点*/ { q=(LinkString *)malloc(sizeof(LinkString)); q->data=p->data; tc->next=q;tc=q; p=p->next; } tc->next=NULL; /*终端结点的next置NULL*/ } int StrLength(LinkString *s) { int n=0; LinkString *p=s->next; while (p!=NULL) /*扫描串s的所有结点*/ { n++;p=p->next; } return(n); } int StrEqual(LinkString *s,LinkString *t) { LinkString *p=s->next,*q=t->next; while (p!=NULL && q!=NULL) /*比较两串的当前结点*/ { if (p->data!=q->data) /*data域不等时返回0*/ return(0); p=p->next;q=q->next; } if (p!=NULL || q!=NULL) /*两串长度不等时返回0*/ return(0); return(1); } LinkString *Concat(LinkString *s,LinkString *t) { LinkString *p=s->next,*q,*tc,*str; str=(LinkString *)malloc(sizeof(LinkString)); /*建立头结点*/ str->next=NULL; tc=str; /*tc总是指向新链表的尾结点*/ while (p!=NULL) /*将s串复制给str*/ { q=(LinkString *)malloc(sizeof(LinkString)); q->data=p->data; tc->next=q;tc=q; p=p->next; } p=t->next; while (p!=NULL) /*将t串复制给str*/ { q=(LinkString *)malloc(sizeof(LinkString)); q->data=p->data; tc->next=q;tc=q; p=p->next; } tc->next=NULL; return(str); } LinkString *SubStr(LinkString *s,int i,int j) { int k=1; LinkString *p=s->next,*q,*tc,*str; str=(LinkString *)malloc(sizeof(LinkString)); /*建立头结点*/ str->next=NULL; tc=str; /*tc总是指向新链表的尾结点*/ while (knext;k++; } if (p!=NULL) { k=1; while (kdata=p->data; tc->next=q;tc=q; p=p->next; k++; } tc->next=NULL; } return(str); } int Index(LinkString *s,LinkString *t) { LinkString *p=s->next,*p1,*q,*q1; int i=0; while (p!=NULL) /*循环扫描s的每个结点*/ { q=t->next; /*子串总是从第一个字符开始比较*/ if (p->data==q->data)/*判定两串当前字符相等*/ { /*若首字符相同,则判定s其后字符是否与t的依次相同*/ p1=p->next;q1=q->next; while (p1!=NULL && q1!=NULL && p1->data==q1->data) { p1=p1->next; q1=q1->next; } if (q1==NULL) /*若都相同,则返回相同的子串的起始位置*/ return(i); } p=p->next;i++; } return(-1); /*若不是子串,返回-1*/ } int InsStr(LinkString *&s,int i,LinkString *t) { int k; LinkString *q=s->next,*p,*str; StrCopy(str,t); /*将t复制到str*/ p=str;str=str->next; free(p); /*删除str的头结点*/ for (k=1;knext; } p->next=str; /*将str链表链接到*p之后*/ while (str->next!=NULL) /*由str指向尾结点*/ str=str->next; str->next=q; /*将*q链接到*str之后*/ return(1); } int DelStr(LinkString *&s,int i,int j) { int k; LinkString *q=s->next,*p,*t; for (k=1;knext; } for (k=1;knext; free(t); } p->next=q; return(1); } LinkString *RepStrAll(LinkString *s,LinkString *s1,LinkString *s2) { int i; i=Index(s,s1); while (i>=0) { DelStr(s,i+1,StrLength(s1)); /*删除串s1*/ InsStr(s,i+1,s2); /*插入串s2*/ i=Index(s,s1); } return(s); } void DispStr(LinkString *s) { LinkString *p=s->next; while (p!=NULL) { printf(\"%c\",p->data); p=p->next; } printf(\"\\n\"); } void main() { LinkString *s1,*s2,*s3,*s4,*s5,*s6,*s7; Assign(s1,\"abcd\"); printf(\"s1:\");DispStr(s1); printf(\"s1的长度:%d\\n\",StrLength(s1)); printf(\"s1=>s2\\n\"); StrCopy(s2,s1); printf(\"s2:\");DispStr(s2); printf(\"s1和s2%s\\n\",(StrEqual(s1,s2)==1?\"相同\":\"不相同\")); Assign(s3,\"12345678\"); printf(\"s3:\");DispStr(s3); printf(\"s1和s3连接=>s4\\n\"); s4=Concat(s1,s3); printf(\"s4:\");DispStr(s4); printf(\"s3[2..5]=>s5\\n\"); s5=SubStr(s3,2,4); printf(\"s5:\");DispStr(s5); Assign(s6,\"567\"); printf(\"s6:\");DispStr(s6); printf(\"s6在s3中位置:%d\\n\",Index(s3,s6)); printf(\"从s3中删除s3[3..6]字符\\n\"); DelStr(s3,3,4); printf(\"s3:\");DispStr(s3); printf(\"从s4中将s6替换成s1=>s7\\n\"); s7=RepStrAll(s4,s6,s1); printf(\"s7:\");DispStr(s7); } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"tree/btree.html":{"url":"tree/btree.html","title":"二叉树基本运算","keywords":"","body":"二叉树的基本运算 By C++ #include #include #define MaxSize 100 #define MaxWidth 40 typedef char ElemType; typedef struct tnode { ElemType data; struct tnode *lchild,*rchild; } BTNode; void CreateBTree(BTNode * &bt,char *str) /*由str创建二叉链bt*/ { BTNode *St[MaxSize],*p=NULL; int top=-1,k,j=0; char ch; bt=NULL; /*建立的二叉树初始时为空*/ ch=str[j]; while (ch!='\\0') /*str未扫描完时循环*/ { switch(ch) { case '(':top++;St[top]=p;k=1; break; /*为左孩子结点*/ case ')':top--;break; case ',':k=2; break; /*为孩子结点右结点*/ default:p=(BTNode *)malloc(sizeof(BTNode)); p->data=ch;p->lchild=p->rchild=NULL; if (bt==NULL) /**p为二叉树的根结点*/ bt=p; else /*已建立二叉树根结点*/ { switch(k) { case 1:St[top]->lchild=p;break; case 2:St[top]->rchild=p;break; } } } j++; ch=str[j]; } } int BTHeight(BTNode *bt) /*求二叉树高度*/ { int lchilddep,rchilddep; if (bt==NULL) return(0); /*空树的高度为0*/ else { lchilddep=BTHeight(bt->lchild); /*求左子树的高度为lchilddep*/ rchilddep=BTHeight(bt->rchild); /*求右子树的高度为rchilddep*/ return (lchilddep>rchilddep)? (lchilddep+1):(rchilddep+1); } } int NodeCount(BTNode *bt) /*求二叉树bt的结点个数*/ { int num1,num2; if (bt==NULL) /*空树结点个数为0*/ return 0; else { num1=NodeCount(bt->lchild); /*求出左子树的结点数*/ num2=NodeCount(bt->rchild); /*求出右子树的结点数*/ return (num1+num2+1); } } int LeafCount(BTNode *bt) /*求二叉树bt的叶子结点个数*/ { int num1,num2; if (bt==NULL) /*空树叶子结点个数为0*/ return 0; else if (bt->lchild==NULL && bt->rchild==NULL) return 1; /*若为叶子结点返回1*/ else { num1=LeafCount(bt->lchild); /*求出左子树的叶子结点数*/ num2=LeafCount(bt->rchild); /*求出右子树的叶子结点数*/ return (num1+num2); } } void DispBTree(BTNode *bt) /*以括号表示法输出二叉树*/ { if (bt!=NULL) { printf(\"%c\",bt->data); if (bt->lchild!=NULL || bt->rchild!=NULL) { printf(\"(\"); DispBTree(bt->lchild); /*递归处理左子树*/ if (bt->rchild!=NULL) printf(\",\"); DispBTree(bt->rchild); /*递归处理右子树*/ printf(\")\"); } } } void DispBTree1(BTNode *bt) /*以凹入表示法输出一棵二叉树*/ { BTNode *St[MaxSize],*p; int Level[MaxSize][2],top=-1,n,i,width=4; char type; /*取值L表示为左结点,R表示为右结点,B表示为根结点*/ if (bt!=NULL) { top++; St[top]=bt; /*根结点入栈*/ Level[top][0]=width; Level[top][1]=2; /*2表示是根*/ while (top>-1) { p=St[top]; /*退栈并凹入显示该结点值*/ n=Level[top][0]; switch(Level[top][1]) { case 0:type='L';break; /*左结点之后输出(L)*/ case 1:type='R';break; /*右结点之后输出(R)*/ case 2:type='B';break; /*根结点之后前输出(B)*/ } for (i=1;idata,type); for (i=n+1;irchild!=NULL) { /*将右子树根结点入栈*/ top++; St[top]=p->rchild; Level[top][0]=n+width; /*场宽增width,即缩width格后再输出*/ Level[top][1]=1; /*1表示是右子树*/ } if (p->lchild!=NULL) { /*将左子树根结点入栈*/ top++; St[top]=p->lchild; Level[top][0]=n+width; /*显示场宽增width*/ Level[top][1]=0; /*0表示是左子树*/ } } } } void main() { BTNode *bt; CreateBTree(bt,\"A(B(D,E(G,H)),C(,F(I)))\"); /*构造图5.10(a)所示的二叉树*/ printf(\"二叉树bt:\");DispBTree(bt);printf(\"\\n\"); printf(\"bt的高度:%d\\n\",BTHeight(bt)); printf(\"bt的结点数:%d\\n\",NodeCount(bt)); printf(\"bt的叶子结点数:%d\\n\",LeafCount(bt)); printf(\"bt凹入表示:\\n\");DispBTree1(bt);printf(\"\\n\"); } By Golang // Package binarysearchtree creates a ItemBinarySearchTree data structure for the Item type package binarysearchtree import ( \"fmt\" \"sync\" ) // Item the type of the binary search tree type Item interface{} // Node a single node that composes the tree type Node struct { key int value Item left *Node //left right *Node //right } // ItemBinarySearchTree the binary search tree of Items type ItemBinarySearchTree struct { root *Node lock sync.RWMutex } // Insert inserts the Item t in the tree func (bst *ItemBinarySearchTree) Insert(key int, value Item) { bst.lock.Lock() defer bst.lock.Unlock() n := &Node{key, value, nil, nil} if bst.root == nil { bst.root = n } else { insertNode(bst.root, n) } } // internal function to find the correct place for a node in a tree func insertNode(node, newNode *Node) { if newNode.key n.key { return search(n.right, key) } return true } // Remove removes the Item with key `key` from the tree func (bst *ItemBinarySearchTree) Remove(key int) { bst.lock.Lock() defer bst.lock.Unlock() remove(bst.root, key) } // internal recursive function to remove an item func remove(node *Node, key int) *Node { if node == nil { return nil } if key node.key { node.right = remove(node.right, key) return node } // key == node.key if node.left == nil && node.right == nil { node = nil return nil } if node.left == nil { node = node.right return node } if node.right == nil { node = node.left return node } leftmostrightside := node.right for { //find smallest value on the right side if leftmostrightside != nil && leftmostrightside.left != nil { leftmostrightside = leftmostrightside.left } else { break } } node.key, node.value = leftmostrightside.key, leftmostrightside.value node.right = remove(node.right, node.key) return node } // String prints a visual representation of the tree func (bst *ItemBinarySearchTree) String() { bst.lock.Lock() defer bst.lock.Unlock() fmt.Println(\"------------------------------------------------\") stringify(bst.root, 0) fmt.Println(\"------------------------------------------------\") } // internal recursive function to print a tree func stringify(n *Node, level int) { if n != nil { format := \"\" for i := 0; i Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 17:43:18 "},"tree/order.html":{"url":"tree/order.html","title":"二叉树4种遍历算法","keywords":"","body":"二叉树的四种遍历算法 #include #include #define MaxSize 100 #define MaxWidth 40 typedef char ElemType; typedef struct tnode { ElemType data; struct tnode *lchild,*rchild; } BTNode; void CreateBTree(BTNode * &bt,char *str) /*由str创建二叉链bt*/ { BTNode *St[MaxSize],*p=NULL; int top=-1,k,j=0; char ch; bt=NULL; /*建立的二叉树初始时为空*/ ch=str[j]; while (ch!='\\0') /*str未扫描完时循环*/ { switch(ch) { case '(':top++;St[top]=p;k=1; break; /*为左孩子结点*/ case ')':top--;break; case ',':k=2; break; /*为孩子结点右结点*/ default:p=(BTNode *)malloc(sizeof(BTNode)); p->data=ch;p->lchild=p->rchild=NULL; if (bt==NULL) /**p为二叉树的根结点*/ bt=p; else /*已建立二叉树根结点*/ { switch(k) { case 1:St[top]->lchild=p;break; case 2:St[top]->rchild=p;break; } } } j++; ch=str[j]; } } void DispBTree(BTNode *bt) /*以括号表示法输出二叉树*/ { if (bt!=NULL) { printf(\"%c\",bt->data); if (bt->lchild!=NULL || bt->rchild!=NULL) { printf(\"(\"); DispBTree(bt->lchild); /*递归处理左子树*/ if (bt->rchild!=NULL) printf(\",\"); DispBTree(bt->rchild); /*递归处理右子树*/ printf(\")\"); } } } // 先序遍历序列 void PreOrder(BTNode *bt) { if (bt!=NULL) { printf(\"%c \",bt->data); PreOrder(bt->lchild); PreOrder(bt->rchild); } } // 中序遍历序列 void InOrder(BTNode *bt) { if (bt!=NULL) { InOrder(bt->lchild); printf(\"%c \",bt->data); InOrder(bt->rchild); } } // 后序遍历序列 void PostOrder(BTNode *bt) { if (bt!=NULL) { PostOrder(bt->lchild); PostOrder(bt->rchild); printf(\"%c \",bt->data); } } // 层次遍历序列 void LevelOrder(BTNode *b) { BTNode *p; BTNode *qu[MaxSize]; /*定义环形队列,存放结点指针*/ int front,rear; /*定义队头和队尾指针*/ front=rear=-1; /*置队列为空队列*/ rear++; qu[rear]=b; /*根结点指针进入队列*/ while (front!=rear) /*队列不为空*/ { front=(front+1)%MaxSize; p=qu[front]; /*队头出队列*/ printf(\"%c \",p->data); /*访问结点*/ if (p->lchild!=NULL) /*有左孩子时将其进队*/ { rear=(rear+1)%MaxSize; qu[rear]=p->lchild; } if (p->rchild!=NULL) /*有右孩子时将其进队*/ { rear=(rear+1)%MaxSize; qu[rear]=p->rchild; } } } void main() { BTNode *bt; CreateBTree(bt,\"A(B(D,E(G,H)),C(,F(I)))\"); /*构造图5.10(a)所示的二叉树*/ printf(\"二叉树bt:\");DispBTree(bt);printf(\"\\n\"); printf(\"先序遍历序列:\");PreOrder(bt);printf(\"\\n\"); printf(\"中序遍历序列:\");InOrder(bt);printf(\"\\n\"); printf(\"后序遍历序列:\");PostOrder(bt);printf(\"\\n\"); printf(\"层次遍历序列:\");LevelOrder(bt);printf(\"\\n\"); } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"tree/huffman.html":{"url":"tree/huffman.html","title":"哈夫曼树","keywords":"","body":"哈夫曼树 #include #define N 50 /*叶子结点数*/ #define M 2*N-1 /*树中结点总数*/ typedef struct { char data; /*结点值*/ double weight; /*权重*/ int parent; /*双亲结点*/ int lchild; /*左孩子结点*/ int rchild; /*右孩子结点*/ } HTNode; typedef struct { char cd[N]; /*存放哈夫曼码*/ int start; } HCode; void CreateHT(HTNode ht[],int n) { int i,k,lnode,rnode; double min1,min2; for (i=0;i Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"graph/creatematix.html":{"url":"graph/creatematix.html","title":"有向图连接矩阵","keywords":"","body":"有向图连接矩阵 #include #define MAXVEX 100 typedef char VertexType[3]; /*定义VertexType为char数组类型*/ typedef struct vertex { int adjvex; /*顶点编号*/ VertexType data; /*顶点的信息*/ } VType; /*顶点类型*/ typedef struct graph { int n,e; /*n为实际顶点数,e为实际边数*/ VType vexs[MAXVEX]; /*顶点集合*/ int edges[MAXVEX][MAXVEX]; /*边的集合*/ } AdjMatix; /*图的邻接矩阵类型*/ int CreateMatix(AdjMatix &g) { int i,j,k,b,t; int w; printf(\"顶点数(n)和边数(e):\"); scanf(\"%d%d\",&g.n,&g.e); for (i=0;i\",k); printf(\" 起点号 终点号 权值:\"); scanf(\"%d%d%d\",&b,&t,&w); if (b0) g.edges[b][t]=w; else { printf(\"输入错误!\\n\"); return(0); } } return(1); } void DispMatix(AdjMatix g) { int i,j; printf(\"\\n图的邻接矩阵:\\n\"); for (i=0;i Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"graph/createadjlist.html":{"url":"graph/createadjlist.html","title":"有向图连接链表","keywords":"","body":"有向图连接链表 By C++ #include #include #define MAXVEX 100 typedef char VertexType[3]; typedef struct edgenode { int adjvex; /*邻接点序号*/ int value; /*边的权值*/ struct edgenode *next; /*下一条边的顶点*/ } ArcNode; /*每个顶点建立的单链表中结点的类型*/ typedef struct vexnode { VertexType data; /*结点信息*/ ArcNode *firstarc; /*指向第一条边结点*/ } VHeadNode; /*单链表的头结点类型*/ typedef struct { int n,e; /*n为实际顶点数,e为实际边数*/ VHeadNode adjlist[MAXVEX]; /*单链表头结点数组*/ } AdjList; /*图的邻接表类型*/ int CreateAdjList(AdjList *&G) /*建立有向图的邻接表*/ { int i,b,t,w; ArcNode *p; G=(AdjList *)malloc(sizeof(AdjList)); printf(\"顶点数(n),边数(e):\"); scanf(\"%d%d\",&G->n,&G->e); for (i=0;in;i++) { printf(\" 序号为%d的顶点信息:\", i); scanf(\"%s\",G->adjlist[i].data); G->adjlist[i].firstarc=NULL; } for (i=0;ie;i++) { printf(\" 序号为边=>\",i); printf(\" 起点号 终点号 权值:\"); scanf(\"%d%d%d\",&b,&t,&w); if (bn && tn && w>0) { p=(ArcNode *)malloc(sizeof(ArcNode)); /*建立*p结点*/ p->value=w;p->adjvex=t; p->next=G->adjlist[b].firstarc; /**p插入到adjlist[b]的单链表之首*/ G->adjlist[b].firstarc=p; } else { printf(\"输入错误!\\n\"); return(0); } } return(1); } void DispAdjList(AdjList *G) { int i; ArcNode *p; printf(\"图的邻接表表示如下:\\n\"); for (i=0;in;i++) { printf(\" [%d,%3s]=>\",i,G->adjlist[i].data); p=G->adjlist[i].firstarc; while (p!=NULL) { printf(\"(%d,%d)->\",p->adjvex,p->value); p=p->next; } printf(\"∧\\n\"); } } void main() { AdjList *G; CreateAdjList(G); DispAdjList(G); } By Golang // Package graph creates a ItemGraph data structure for the Item type package graph import ( \"fmt\" \"sync\" ) // Item the type of the binary search tree type Item interface{} // Node a single node that composes the tree type Node struct { value Item } func (n *Node) String() string { return fmt.Sprintf(\"%v\", n.value) } // ItemGraph the Items graph type ItemGraph struct { nodes []*Node edges map[Node][]*Node lock sync.RWMutex } // AddNode adds a node to the graph func (g *ItemGraph) AddNode(n *Node) { g.lock.Lock() g.nodes = append(g.nodes, n) g.lock.Unlock() } // AddEdge adds an edge to the graph func (g *ItemGraph) AddEdge(n1, n2 *Node) { g.lock.Lock() if g.edges == nil { g.edges = make(map[Node][]*Node) } g.edges[*n1] = append(g.edges[*n1], n2) g.edges[*n2] = append(g.edges[*n2], n1) g.lock.Unlock() } // AddEdge adds an edge to the graph func (g *ItemGraph) String() { g.lock.RLock() s := \"\" for i := 0; i \" near := g.edges[*g.nodes[i]] for j := 0; j Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 17:41:08 "},"graph/bfs.html":{"url":"graph/bfs.html","title":"广度优先遍历","keywords":"","body":"广度优先遍历 #include #include #include #define MAXVEX 100 typedef char VertexType[3]; /*定义VertexType为char数组类型*/ typedef struct vertex { int adjvex; /*顶点编号*/ VertexType data; /*顶点的信息*/ } VType; /*顶点类型*/ typedef struct graph { int n,e; /*n为实际顶点数,e为实际边数*/ VType vexs[MAXVEX]; /*顶点集合*/ int edges[MAXVEX][MAXVEX]; /*边的集合*/ } AdjMatix; /*图的邻接矩阵类型*/ typedef struct edgenode { int adjvex; /*邻接点序号*/ int value; /*边的权值*/ struct edgenode *next; /*下一条边的顶点*/ } ArcNode; /*每个顶点建立的单链表中结点的类型*/ typedef struct vexnode { VertexType data; /*结点信息*/ ArcNode *firstarc; /*指向第一条边结点*/ } VHeadNode; /*单链表的头结点类型*/ typedef struct { int n,e; /*n为实际顶点数,e为实际边数*/ VHeadNode adjlist[MAXVEX]; /*单链表头结点数组*/ } AdjList; /*图的邻接表类型*/ void DispAdjList(AdjList *G) { int i; ArcNode *p; printf(\"图的邻接表表示如下:\\n\"); for (i=0;in;i++) { printf(\" [%d,%3s]=>\",i,G->adjlist[i].data); p=G->adjlist[i].firstarc; while (p!=NULL) { printf(\"(%d,%d)->\",p->adjvex,p->value); p=p->next; } printf(\"∧\\n\"); } } void MatToList(AdjMatix g,AdjList *&G) /*例6.3算法:将邻接矩阵g转换成邻接表G*/ { int i,j; ArcNode *p; G=(AdjList *)malloc(sizeof(AdjList)); for (i=0;iadjlist[i].firstarc=NULL; strcpy(G->adjlist[i].data,g.vexs[i].data); } for (i=0;i=0;j--) if (g.edges[i][j]!=0) /*邻接矩阵的当前元素不为0*/ { p=(ArcNode *)malloc(sizeof(ArcNode));/*创建一个结点*p*/ p->value=g.edges[i][j];p->adjvex=j; p->next=G->adjlist[i].firstarc; /*将*p链到链表后*/ G->adjlist[i].firstarc=p; } G->n=g.n;G->e=g.e; } void BFS(AdjList *G,int vi) /*对邻接表g从顶点vi开始进行广宽优先遍历*/ { int i,v,visited[MAXVEX]; int Qu[MAXVEX],front=0,rear=0; /*循环队列*/ ArcNode *p; for (i=0;in;i++) /*给visited数组置初值0*/ visited[i]=0; printf(\"%d \",vi); /*访问初始顶点*/ visited[vi]=1; /*置已访问标识*/ rear=(rear=1)%MAXVEX; /*循环移动队尾指针*/ Qu[rear]=vi; /*初始顶点进队*/ while (front!=rear) /*队列不为空时循环*/ { front=(front+1) % MAXVEX; v=Qu[front]; /*顶点v出队*/ p=G->adjlist[v].firstarc; /*找v的第一个邻接点*/ while (p!=NULL) /*找v的所有邻接点*/ { if (visited[p->adjvex]==0) /*未访问过则访问之*/ { visited[p->adjvex]=1; /*置已访问标识*/ printf(\"%d \",p->adjvex);/*访问该点并使之入队列*/ rear=(rear+1) % MAXVEX; /*循环移动队尾指针*/ Qu[rear]=p->adjvex; /*顶点p->adjvex进队*/ } p=p->next; /*找v的下一个邻接点*/ } } } void main() { int i,j; AdjMatix g; AdjList *G; int a[5][5]={ {0,1,0,1,0},{1,0,1,0,0},{0,1,0,1,1},{1,0,1,0,1},{0,0,1,1,0} }; char *vname[MAXVEX]={\"a\",\"b\",\"c\",\"d\",\"e\"}; g.n=5;g.e=12; /*建立图6.1(a)的无向图,每1条无向边算为2条有向边*/ for (i=0;i Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 16:09:40 "},"graph/dfs.html":{"url":"graph/dfs.html","title":"深度优先遍历","keywords":"","body":"深度优先遍历 #include #include #include #define MAXVEX 100 typedef char VertexType[3]; /*定义VertexType为char数组类型*/ typedef struct vertex { int adjvex; /*顶点编号*/ VertexType data; /*顶点的信息*/ } VType; /*顶点类型*/ typedef struct graph { int n,e; /*n为实际顶点数,e为实际边数*/ VType vexs[MAXVEX]; /*顶点集合*/ int edges[MAXVEX][MAXVEX]; /*边的集合*/ } AdjMatix; /*图的邻接矩阵类型*/ typedef struct edgenode { int adjvex; /*邻接点序号*/ int value; /*边的权值*/ struct edgenode *next; /*下一条边的顶点*/ } ArcNode; /*每个顶点建立的单链表中结点的类型*/ typedef struct vexnode { VertexType data; /*结点信息*/ ArcNode *firstarc; /*指向第一条边结点*/ } VHeadNode; /*单链表的头结点类型*/ typedef struct { int n,e; /*n为实际顶点数,e为实际边数*/ VHeadNode adjlist[MAXVEX]; /*单链表头结点数组*/ } AdjList; /*图的邻接表类型*/ void DispAdjList(AdjList *G) { int i; ArcNode *p; printf(\"图的邻接表表示如下:\\n\"); for (i=0;in;i++) { printf(\" [%d,%3s]=>\",i,G->adjlist[i].data); p=G->adjlist[i].firstarc; while (p!=NULL) { printf(\"(%d,%d)->\",p->adjvex,p->value); p=p->next; } printf(\"∧\\n\"); } } void MatToList(AdjMatix g,AdjList *&G) /*例6.3算法:将邻接矩阵g转换成邻接表G*/ { int i,j; ArcNode *p; G=(AdjList *)malloc(sizeof(AdjList)); for (i=0;iadjlist[i].firstarc=NULL; strcpy(G->adjlist[i].data,g.vexs[i].data); } for (i=0;i=0;j--) if (g.edges[i][j]!=0) /*邻接矩阵的当前元素不为0*/ { p=(ArcNode *)malloc(sizeof(ArcNode));/*创建一个结点*p*/ p->value=g.edges[i][j];p->adjvex=j; p->next=G->adjlist[i].firstarc; /*将*p链到链表后*/ G->adjlist[i].firstarc=p; } G->n=g.n;G->e=g.e; } int visited[MAXVEX]; void DFS(AdjList *g,int vi) /*对邻接表G从顶点vi开始进行深度优先遍历*/ { ArcNode *p; printf(\"%d \",vi); /*访问vi顶点*/ visited[vi]=1; /*置已访问标识*/ p=g->adjlist[vi].firstarc; /*找vi的第一个邻接点*/ while (p!=NULL) /*找vi的所有邻接点*/ { if (visited[p->adjvex]==0) DFS(g,p->adjvex); /*从vi未访问过的邻接点出发深度优先搜索*/ p=p->next; /*找vi的下一个邻接点*/ } } void DFS1(AdjList *G,int vi) /*非递归深度优先遍历算法*/ { ArcNode *p; ArcNode *St[MAXVEX]; int top=-1,v; printf(\"%d \",vi); /*访问vi顶点*/ visited[vi]=1; /*置已访问标识*/ top++; /*将初始顶点vi的firstarc指针进栈*/ St[top]=G->adjlist[vi].firstarc; while (top>-1) /*栈不空循环*/ { p=St[top];top--; /*出栈一个顶点为当前顶点*/ while (p!=NULL) /*循环搜索其相邻顶点*/ { v=p->adjvex; /*取相邻顶点的编号*/ if (visited[v]==0) /*若该顶点未访问过*/ { printf(\"%d \",v); /*访问v顶点*/ visited[v]=1; /*置访问标识*/ top++; /*将该顶点的第1个相邻顶点进栈*/ St[top]=G->adjlist[v].firstarc; break; /*退出当前顶点的搜索*/ } p=p->next; /*找下一个相邻顶点*/ } } } void main() { int i,j; AdjMatix g; AdjList *G; int a[5][5]={ {0,1,0,1,0},{1,0,1,0,0},{0,1,0,1,1},{1,0,1,0,1},{0,0,1,1,0} }; char *vname[MAXVEX]={\"a\",\"b\",\"c\",\"d\",\"e\"}; g.n=5;g.e=12; /*建立图6.1(a)的无向图,每1条无向边算为2条有向边*/ for (i=0;i Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 16:09:53 "},"graph/prim.html":{"url":"graph/prim.html","title":"普里姆算法","keywords":"","body":"普里姆算法 #include #define MAXVEX 100 #define INF 32767 /*INF表示∞*/ void Prim(int cost[][MAXVEX],int n,int v) /*输出最小生成树的每条边*/ { int lowcost[MAXVEX],min; int closest[MAXVEX],i,j,k; for (i=0;i Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"graph/kruskal.html":{"url":"graph/kruskal.html","title":"克鲁斯卡尔算法","keywords":"","body":"克鲁斯卡尔算法 #include #define MAXVEX 100 typedef struct { int u; /*边的起始顶点*/ int v; /*边的终止顶点*/ int w; /*边的权值*/ } Edge; void Kruskal(Edge E[],int n,int e) { int i,j,m1,m2,sn1,sn2,k; int vset[MAXVEX]; for (i=0;i Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"graph/dijkstra.html":{"url":"graph/dijkstra.html","title":"狄克斯特拉算法","keywords":"","body":"狄克斯特拉算法 #include #define MAXVEX 100 #define INF 32767 void Dijkstra(int cost[][MAXVEX],int n,int v) { int dist[MAXVEX],path[MAXVEX]; int s[MAXVEX]; int mindis,i,j,u,pre; for (i=0;i%d:\",v,i); if (s[i]==1) { printf(\"路径长度为%2d \",dist[i]); pre=i; printf(\"路径逆序为\"); while (pre!=v) /*一直求解到初始顶点*/ { printf(\"%d,\",pre); pre=path[pre]; } printf(\"%d\\n\",pre); } else printf(\"不存在路径\\n\"); } } } void main() { int cost[6][MAXVEX]={ /*图6.9的代价矩阵*/ {0,50,10,INF,INF,INF}, {INF,0,15,50,10,INF}, {20,INF,0,15,INF,INF}, {INF,20,INF,0,35,INF}, {INF,INF,INF,30,0,INF}, {INF,INF,INF,3,INF,0}}; Dijkstra(cost,6,1); printf(\"\\n\"); } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"graph/floyed.html":{"url":"graph/floyed.html","title":"弗洛伊德算法","keywords":"","body":"弗洛伊德算法 #include #define MAXVEX 100 #define INF 32767 void Floyed(int cost[][MAXVEX],int n) { int A[MAXVEX][MAXVEX],path[MAXVEX][MAXVEX]; int i,j,k,pre; for (i=0;i(A[i][k]+A[k][j])) { A[i][j]=A[i][k]+A[k][j]; path[i][j]=k; } } printf(\"\\n Floyed算法求解如下:\\n\"); for (i=0;i%d:\",i,j); if (A[i][j]==INF) { if (i!=j) printf(\"不存在路径\\n\"); } else { printf(\"路径长度为:%3d \",A[i][j]); printf(\"路径为%d \",i); pre=path[i][j]; while (pre!=-1) { printf(\"%d \",pre); pre=path[pre][j]; } printf(\"%d\\n\",j); } } } void main() { int cost[6][MAXVEX]={ /*图6.9的代价矩阵*/ {0,50,10,INF,INF,INF}, {INF,0,15,50,10,INF}, {20,INF,0,15,INF,INF}, {INF,20,INF,0,35,INF}, {INF,INF,INF,30,0,INF}, {INF,INF,INF,3,INF,0}}; Floyed(cost,6); printf(\"\\n\"); } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"search/seqsearch.html":{"url":"search/seqsearch.html","title":"顺序查找","keywords":"","body":"顺序查找 #include #define MaxSize 100 typedef int KeyType; typedef char ElemType[10]; typedef struct { KeyType key; /*存放关键字,KeyType为关键字类型*/ ElemType data; /*其他数据, ElemType为其他数据的类型*/ } LineList; int SeqSearch(LineList R[],int n,KeyType k) { int i=0; while (i=n) return(-1); else return(i); } void main() { KeyType a[]={3,9,1,5,8,10,6,7,2,4},k=6; LineList R[MaxSize]; int n=10,i; for (i=0;i=0) printf(\"R[%d].key=%d\\n\",i,k); else printf(\"%d不在a中\\n\",k); } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"search/binsearch.html":{"url":"search/binsearch.html","title":"二分法查找","keywords":"","body":"二分法查找 #include #define MaxSize 100 typedef int KeyType; typedef char ElemType[10]; typedef struct { KeyType key; /*存放关键字,KeyType为关键字类型*/ ElemType data; /*其他数据, ElemType为其他数据的类型*/ } LineList; int BinSearch(LineList R[],int n,KeyType k) { int i,low=0,high=n-1,mid; int find=0; /*find=0表示未找到;find=1表示已找到*/ while (lowR[mid].key) low=mid+1; else { i=mid; find=1; } } if (find==0) return(-1); else return(i); } void main() { KeyType a[]={2,4,7,9,10,14,18,26,32,40},k=7; LineList R[MaxSize]; int n=10,i; for (i=0;i=0) printf(\"R[%d].key=%d\\n\",i,k); else printf(\"%d不在a中\\n\",k); } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"search/blksearch.html":{"url":"search/blksearch.html","title":"分块查找","keywords":"","body":"分块查找 #include #define MaxSize 100 #define MaxBlk 20 typedef int KeyType; typedef char ElemType[10]; typedef struct { KeyType key; /*存放关键字,KeyType为关键字类型*/ ElemType data; /*其他数据, ElemType为其他数据的类型*/ } LineList; typedef struct { KeyType key; int low,high; } IDXType; /*索引表的类型*/ int BlkSearch(LineList R[],IDXType idx[],int m,KeyType k) { int low=0,high=m-1,mid,i,j,find=0; while (lowidx[mid].key) low=mid+1; else { high=mid-1; find=1; } } if (low=j) return(-1); else return(i); } void main() { KeyType a[]={9,22,12,14,35,42,44,38,48,60,58,47,78,80,77,82},k=48; LineList R[MaxSize]; IDXType I[MaxBlk]; int n=16,m=4,i; for (i=0;i=0) printf(\"R[%d].key=%d\\n\",i,k); else printf(\"%d不在a中\\n\",k); } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"search/bstree.html":{"url":"search/bstree.html","title":"二叉排序树查找","keywords":"","body":"二叉树排序查找 #include #include typedef int KeyType; typedef char ElemType[10]; typedef struct tnode { KeyType key; ElemType data; struct tnode *lchild,*rchild; } BSTNode; BSTNode *BSTSearch(BSTNode *bt,KeyType k) { BSTNode *p=bt; while (p!=NULL && p->key!=k) { if (kkey) p=p->lchild; /*沿左子树查找*/ else p=p->rchild; /*沿右子树查找*/ } return(p); } int BSTInsert(BSTNode *&bt,KeyType k) { BSTNode *f,*p=bt; while (p!=NULL) { if (p->key==k) return(0); f=p; /*f指向*p结点的双亲结点*/ if (p->key>k) p=p->lchild; /*在左子树中查找*/ else p=p->rchild; /*在右子树中查找*/ } p=(BSTNode *)malloc(sizeof(BSTNode)); /*建立新结点*/ p->key=k; p->lchild=p->rchild=NULL; if (bt==NULL) /*原树为空时,*p作为根结点插入*/ bt=p; else if (kkey) f->lchild=p; /*插入*p作为*f的左孩子*/ else f->rchild=p; /*插入*p作为*f的右孩子*/ return(1); } void CreateBST(BSTNode *&bt,KeyType str[],int n) { bt=NULL; /*初始时bt为空树*/ int i=0; while (ikey); if (bt->lchild!=NULL || bt->rchild!=NULL) { printf(\"(\"); DispBST(bt->lchild); /*递归处理左子树*/ if (bt->rchild!=NULL) printf(\",\"); DispBST(bt->rchild); /*递归处理右子树*/ printf(\")\"); } } } int BSTDelete(BSTNode *&bt,KeyType k) { BSTNode *p=bt,*f,*r,*f1; f=NULL; /*p指向待比较的结点,f指向*p的双亲结点*/ while (p!=NULL && p->key!=k)/*查找值域为x的结点*/ { f=p; if (p->key>k) p=p->lchild; /*在左子树中查找*/ else p=p->rchild; /*在右子树中查找*/ } if (p==NULL) /*未找到key域为k的结点*/ return(0); else if (p->lchild==NULL) /**p为被删结点,若它无左子树*/ { if (f==NULL) /**p是根结点,则用右孩子替换它*/ bt=p->rchild; else if (f->lchild==p) /**p是双亲结点的左孩子,则用其右孩子替换它*/ { f->lchild=p->rchild; free(p); } else if(f->rchild==p) /**p是双亲结点的右孩子,则用其右孩子替换它*/ { f->rchild=p->rchild; free(p); } } else if (p->rchild==NULL) /**p为被删结点,若它无右子树*/ { if (f==NULL) /**p是根结点,则用左孩子替换它*/ bt=p->lchild; if (f->lchild==p) /**p是双亲结点的左孩子,则用其左孩子替换它*/ { f->lchild=p->lchild; free(p); } else if(f->rchild==p) /**p是双亲结点的右孩子,则用其左孩子替换它*/ { f->rchild=p->lchild; free(p); } } else /**p为被删结点,若它有左子树和右子树*/ { f1=p;r=p->lchild; /*查找*p的左子树中的最右下结点*r*/ while (r->rchild!=NULL) /**r一定是无右子树的结点,*f1作为r的双亲*/ { f1=r; r=r->rchild; } if (f1->lchild==r) /**r是*f1的左孩子,删除*r*/ f1->lchild=r->rchild; else if (f1->rchild==r) /**r是*f1的右孩子,删除*r*/ f1->rchild=r->lchild; r->lchild=p->lchild; /*以下语句是用*r替代*p*/ r->rchild=p->rchild; if (f==NULL) /**f为根结点*/ bt=r; /*被删结点是根结点*/ else if (f->lchild==p) /**p是*f的左孩子*/ f->lchild=r; else /**p是*f的右孩子*/ f->rchild=r; free(p); } return(1); } void main() { BSTNode *bt=NULL,*p; KeyType a[]={10,6,12,8,3,20,9,25,15},k; int n=9; CreateBST(bt,a,n); printf(\"BST:\");DispBST(bt);printf(\"\\n\"); k=9; printf(\"查找关键字为%d的结点\\n\",k); p=BSTSearch(bt,k); if (p!=NULL) printf(\"存在关键字为%d结点\\n\",k); else printf(\"不存在关键字为%d结点\\n\",k); k=7; printf(\"插入关键字为%d的结点\\n\",k); BSTInsert(bt,k); printf(\"BST:\");DispBST(bt);printf(\"\\n\"); k=10; printf(\"删除关键字为%d的结点\\n\",k); BSTDelete(bt,k); printf(\"BST:\");DispBST(bt);printf(\"\\n\"); } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"search/hashtable.html":{"url":"search/hashtable.html","title":"哈希表查找","keywords":"","body":"哈希表查找 By C++ #include #define MaxSize 100 /*哈希表最大长度*/ typedef int KeyType; typedef struct { KeyType key; /*关键字值*/ int si; /*探查次数*/ } HashTable; void CreateHT(HashTable ht[],KeyType a[],int n,int m,int p) /*构造哈希表*/ { int i,d,cnt; for (i=0;i By Golang // Package hashtable creates a ValueHashtable data structure for the Item type package hashtable import ( \"fmt\" \"sync\" ) // Key the key of the dictionary type Key interface{} // Value the content of the dictionary type Value interface{} // ValueHashtable the set of Items type ValueHashtable struct { items map[int]Value lock sync.RWMutex } // the hash() private function uses the famous Horner's method // to generate a hash of a string with O(n) complexity func hash(k Key) int { key := fmt.Sprintf(\"%s\", k) h := 0 for i := 0; i Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 17:47:47 "},"search/hash.html":{"url":"search/hash.html","title":"哈希查找","keywords":"","body":"哈希查找 #include #include #define MaxSize 100 /*哈希表最大长度*/ typedef int KeyType; typedef struct node { KeyType key; /*关键字值*/ int si; /*探查次数*/ struct node *next; } Node; /*数据结点类型*/ typedef struct { Node *link; } HNode; /*头结点类型*/ void CreateHT(HNode *ht[],KeyType a[],int n,int p) /*构造哈希表*/ { int i,d,cnt; Node *s,*q; for (i=0;ilink=NULL; } for (i=0;ikey=a[i];s->next=NULL; d=a[i]%p; /*求其哈希地址*/ if (ht[d]->link==NULL) { ht[d]->link=s; s->si=cnt; } else { q=ht[d]->link; while (q->next!=NULL) { q=q->next;cnt++; } cnt++; s->si=cnt;q->next=s; } } } void DispHT(HNode *ht[],int n,int p) /*输出哈希表*/ { int i,sum=0; Node *q; printf(\"哈希表:\\n\"); for (i=0;ilink; printf(\"%d:link->\",i); while (q!=NULL) { sum+=q->si; printf(\"[%d,%d]->\",q->key,q->si); q=q->next; } printf(\"∧\\n\"); } printf(\"\\n平均查找长度:ASL=%g\\n\",1.0*sum/n); } void main() { HNode *ht[MaxSize]; KeyType a[]={87,25,310,8,27,132,68,95,187,123,70,63,47}; int n=13,p=13; CreateHT(ht,a,n,p); DispHT(ht,n,p); } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 17:46:29 "},"sort/insertsort.html":{"url":"sort/insertsort.html","title":"插入排序","keywords":"","body":"插入排序 #include #define MaxSize 100 typedef int KeyType; /*关键字类型*/ typedef char ElemType[10]; /*其他数据项类型*/ typedef struct { KeyType key; /*关键字域*/ ElemType data; /*其他数据域*/ } LineList; /*线性表元素类型*/ void InsertSort(LineList R[],int n) { int i,j; LineList tmp; for (i=1;i=0 && tmp.key Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"sort/shellsort.html":{"url":"sort/shellsort.html","title":"希尔排序","keywords":"","body":"希尔排序 #include #define MaxSize 100 typedef int KeyType; /*关键字类型*/ typedef char ElemType[10]; /*其他数据项类型*/ typedef struct { KeyType key; /*关键字域*/ ElemType data; /*其他数据域*/ } LineList; /*线性表元素类型*/ void ShellSort(LineList R[],int n) { int i,j,gap; LineList tmp; gap=n/2; /*增量置初值*/ while (gap>0) { for (i=gap;i=0 && tmp.key Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"sort/selectsort.html":{"url":"sort/selectsort.html","title":"选择排序","keywords":"","body":"选择排序 #include #define MaxSize 100 typedef int KeyType; /*关键字类型*/ typedef char ElemType[10]; /*其他数据项类型*/ typedef struct { KeyType key; /*关键字域*/ ElemType data; /*其他数据域*/ } LineList; /*线性表元素类型*/ void SelectSort(LineList R[],int n) { int i,j,k; LineList tmp; for (i=0;i Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"sort/heapsort.html":{"url":"sort/heapsort.html","title":"堆排序","keywords":"","body":"堆排序 #include #define MaxSize 100 typedef int KeyType; /*关键字类型*/ typedef char ElemType[10]; /*其他数据项类型*/ typedef struct { KeyType key; /*关键字域*/ ElemType data; /*其他数据域*/ } LineList; /*线性表元素类型*/ void Sift(LineList R[],int low,int high) { int i=low,j=2*i; /*R[j]是R[i]的左孩子*/ LineList tmp=R[i]; while (j=1;i--) /*循环建立初始堆*/ Sift(R,i,n); for (i=n;i>=2;i--) /*进行n-1次循环,完成堆排序*/ { tmp=R[1]; /*将第一个元素同当前区间内R[1]对换*/ R[1]=R[i]; R[i]=tmp; Sift(R,1,i-1); /*筛选R[1]结点,得到i-1个结点的堆*/ } } void main() { LineList R[MaxSize]; KeyType a[]={0,75,87,68,92,88,61,77,96,80,72}; /*有效数据从a[1]开始*/ int n=10,i; for (i=0;i Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"sort/bubblesort.html":{"url":"sort/bubblesort.html","title":"冒泡排序","keywords":"","body":"冒泡排序 #include #define MaxSize 100 typedef int KeyType; /*关键字类型*/ typedef char ElemType[10]; /*其他数据项类型*/ typedef struct { KeyType key; /*关键字域*/ ElemType data; /*其他数据域*/ } LineList; /*线性表元素类型*/ void BubbleSort(LineList R[],int n) { int i,j,exchange; LineList tmp; for (i=0;ii;j--) /*比较,找出最小关键字的记录*/ if (R[j].key Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"sort/quicksort.html":{"url":"sort/quicksort.html","title":"快速排序","keywords":"","body":"快速排序 #include #define MaxSize 100 typedef int KeyType; /*关键字类型*/ typedef char ElemType[10]; /*其他数据项类型*/ typedef struct { KeyType key; /*关键字域*/ ElemType data; /*其他数据域*/ } LineList; /*线性表元素类型*/ void QuickSort(LineList R[],int s,int t) /*对R[s]至R[t]的元素进行快速排序*/ { int i=s,j=t; LineList tmp; if (si && R[j].key>tmp.key) j--; /*从右向左扫描,找第1个关键字小于tmp.key的R[j]*/ R[i]=R[j]; /*找到这样的R[j],则R[i]和R[j]交换*/ while (i Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"sort/mergesort.html":{"url":"sort/mergesort.html","title":"归并排序","keywords":"","body":"归并排序 #include #include #define MaxSize 100 typedef int KeyType; /*关键字类型*/ typedef char ElemType[10]; /*其他数据项类型*/ typedef struct { KeyType key; /*关键字域*/ ElemType data; /*其他数据域*/ } LineList; /*线性表元素类型*/ void Merge(LineList R[],int low,int mid,int high) { LineList *R1; int i=low,j=mid+1,k=0; /*k是R1的下标,i、j分别为第1、2段的下标*/ R1=(LineList *)malloc((high-low+1)*sizeof(LineList)); /*动态分配空间*/ while (i Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"sort/radixsort.html":{"url":"sort/radixsort.html","title":"基数排序","keywords":"","body":"基数排序 #include #include #include #define MAXE 20 /*线性表中最多元素个数*/ #define MAXR 10 /*基数的最大取值*/ #define MAXD 8 /*关键字位数的最大取值*/ typedef struct node { char data[MAXD]; /*记录的关键字定义的字符串*/ struct node *next; } RecType; void RadixSort(RecType *&p,int r,int d) /*p为待排序序列链表指针,r为基数,d为关键字位数*/ { RecType *head[MAXR],*tail[MAXR],*t;/*定义各链队的首尾指针*/ int i,j,k; for (i=d-1;i>=0;i--) /*从低位到高位做d趟排序*/ { for (j=0;jdata[i]-'0'; /*找第k个链队*/ if (head[k]==NULL) /*进行分配,即采用尾插法建立单链表*/ { head[k]=p; tail[k]=p; } else { tail[k]->next=p; tail[k]=p; } p=p->next; /*取下一个待排序的元素*/ } p=NULL; for (j=0;jnext=head[j]; t=tail[j]; } } t->next=NULL; /*最后一个结点的next域置NULL*/ } } void main() { RecType *h=NULL,*p,*t; char *A[]={\"75\",\"87\",\"68\",\"92\",\"88\",\"61\",\"77\",\"96\",\"80\",\"72\"}; int i,n=10; for (i=0;idata,A[i]); if (h==NULL) { h=p; t=h; } else { t->next=p; t=p; } } t->next=NULL; printf(\"排序前:\"); for (i=0;idata); p=p->next; } printf(\"\\n\"); } Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 15:01:44 "},"sort/topsort.html":{"url":"sort/topsort.html","title":"拓扑排序算法","keywords":"","body":"拓扑排序算法 #include #include #include #define MAXVEX 100 typedef char VertexType[3]; /*定义VertexType为char数组类型*/ typedef struct vertex { int adjvex; VertexType data; } VType; typedef struct graph { int n,e; /*n为实际顶点数,e为实际边数*/ VType vexs[MAXVEX]; /*顶点集合*/ int edges[MAXVEX][MAXVEX]; /*边的集合*/ } AdjMatix; /*图的邻接矩阵类型*/ typedef struct edgenode { int adjvex; /*邻接点序号*/ int value; /*边的权值*/ struct edgenode *next; /*下一条边的顶点*/ } ArcNode; /*每个顶点建立的单链表中结点的类型*/ typedef struct vexnode { VertexType data; /*结点信息*/ int count; /*存放顶点入度,新增用于拓扑排序*/ ArcNode *firstarc; /*指向第一条边结点*/ } VHeadNode; /*单链表的头结点类型*/ typedef struct { int n,e; /*n为实际顶点数,e为实际边数*/ VHeadNode adjlist[MAXVEX]; /*单链表头结点数组*/ } AdjList; /*图的邻接表类型*/ void DispAdjList(AdjList *G) /*显示邻接表(含顶点入度)*/ { int i; ArcNode *p; printf(\"图的邻接表表示如下:\\n\"); for (i=0;in;i++) { printf(\" [%d,%3s:]=>\",i,G->adjlist[i].data,G->adjlist[i].count); p=G->adjlist[i].firstarc; while (p!=NULL) { printf(\"(%d,%d)->\",p->adjvex,p->value); p=p->next; } printf(\"∧\\n\"); } } void MatToList(AdjMatix g,AdjList *&G) /*例6.3算法:将邻接矩阵g转换成邻接表G*/ { int i,j; ArcNode *p; G=(AdjList *)malloc(sizeof(AdjList)); for (i=0;iadjlist[i].firstarc=NULL; strcpy(G->adjlist[i].data,g.vexs[i].data); } for (i=0;i=0;j--) if (g.edges[i][j]!=0) /*邻接矩阵的当前元素不为0*/ { p=(ArcNode *)malloc(sizeof(ArcNode));/*创建一个结点*p*/ p->value=g.edges[i][j];p->adjvex=j; p->next=G->adjlist[i].firstarc; /*将*p链到链表后*/ G->adjlist[i].firstarc=p; } G->n=g.n;G->e=g.e; } void TopSort(AdjList *G) { int i,j; int St[MAXV],top=-1; /*栈St的指针为top*/ ArcNode *p; for (i=0;i-1) /*栈不为空时循环*/ { i=St[top];top--; /*出栈*/ printf(\"%d \",i); /*输出顶点*/ p=adj[i].firstarc; /*找第一个相邻顶点*/ while (p!=NULL) { j=p->adjvex; adj[j].count--; if (adj[j].count==0)/*入度为0的相邻顶点入栈*/ { top++; St[top]=j; } p=p->nextarc; /*找下一个相邻顶点*/ } } } void main() { int i,j; AdjMatix g; AdjList *G; int a[6][6]={ {0,1,0,10},{1,0,1,0,0},{0,1,0,1,1},{1,0,1,0,1},{0,0,1,1,0} }; char *vname[MAXVEX]={\"a\",\"b\",\"c\",\"d\",\"e\"}; g.n=5;g.e=12; /*建立图6.1(a)的无向图,每1条无向边算为2条有向边*/ for (i=0;i Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2019-03-24 16:10:23 "}}